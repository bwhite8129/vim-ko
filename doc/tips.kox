*tips.txt*      Vim version 7.4 대상.  새로 고침: 2009년 11월 7일


		     VIM 상세 설명서 - Bram Moolenaar 저
				       정지용 역



Vim을 사용할 때의 팁과 아이디어				*tips*

많은 사용자들에게 도움이 될 것 같은 것들이 몇 가지 있습니다.  위키에 훨씬 더
많은 팁이 있습니다.  URL은 http://www.vim.org 에 있습니다.

사용설명서를 잊지말고 확인해보세요.  수많은 유용한 팁이 있습니다.
|usr_toc.txt|.

C 프로그램 편집하기				|C-editing|
식별자가 어디에 쓰였는지 찾기			|ident-search|
xterm 안에서 스크린 전환하기			|xterm-screens|
입력 모드에서 스크롤하기			|scroll-insert|
부드러운 스크롤					|scroll-smooth|
자주 하는 철자 오류 바로잡기			|type-mistakes|
단어나 줄 수 등을 세기				|count-items|
커서 위치를 되돌리기				|restore-position|
파일 이름 바꾸기				|rename-files|
여러 파일에서 이름 바꾸기			|change-name|
외부 명령 속도 높이기				|speed-up|
유용한 매핑들					|useful-mappings|
도움말 파일 압축하기				|gzip-helpfile|
창에서 쉘 명령 실행하기				|shell-window|
16진수 편집					|hex-editing|
자동명령에서 <>표기법 사용하기			|autocmd-<>|
짝이 되는 괄호 강조하기				|match-parens|

==============================================================================
C 프로그램 편집하기					*C-editing*

Vim에는 C 프로그램 편집을 도와주는 여러 가지 기능이 있습니다.  쉽게 이동할 수
있는 태그와 함께 간단히 훓어봅시다:

|usr_29.txt|		사용설명서의 프로그램 코드 탐험하기 장.
|usr_30.txt|		사용설명서의 프로그램 편집하기 장.
|C-indenting|		프로그램을 입력할 때 들여쓰기를 자동으로 하기.
|=|			여러 줄 들여쓰기 맞추기
|format-comments|	주석 형식 맞추기.

|:checkpath|		인클루드한 파일을 조상까지 모두 표시하기.
|[i|			커서 밑의 식별자를 현재 파일 및 인클루드한 파일에서
			찾기.
|[_CTRL-I|		"[i"로 찾은 위치로 이동.
|[I|			현재 파일 및 인클루드한 파일에서 커서 밑의 식별자와
			일치하는 줄을 모두 표시.
|[d|			커서 밑의 식별자를 정의한 곳을 현재 파일 및 인클루드한
			파일에서 찾기.

|CTRL-]|		커서 밑의 태그로 이동 (예를 들어, 함수의 정의).
|CTRL-T|		CTRL-] 명령 전의 위치로 돌아가기.
|:tselect|		여러 일치하는 태그 목록 중 하나 고르기.

|gd|			커서 밑의 지역 변수를 선언한 곳으로 이동.
|gD|			커서 밑의 전역 변수를 선언한 곳으로 이동.r cursor.

|gf|			커서 밑의 파일명으로 이동.

|%|			짝이 되는 (), {}, [], /* */, #if, #else, #endif로 
			이동.
|[/|			이전에 있는 주석의 시작 지점으로 이동.
|]/|			이후에 있는 주석의 끝 지점으로 이동.
|[#|			이전에 있는 닫히지 않은 #if, #ifdef, #else로 이동.
|]#|			이후에 있는 닫히지 않은 #if, #ifdef, #else로 이동.
|[(|			이전에 있는 닫히지 않은 '('로 이동.
|])|			이후에 있는 닫히지 않은 '('로 이동.
|[{|			이전에 있는 닫히지 않은 '{'로 이동.
|]}|			이후에 있는 닫히지 않은 '{'로 이동.

|v_ab|			"[("에서 "])"까지의 블록 하나(a block)를 괄호를
			포함하여 선택.
|v_ib|			"[("에서 "])"까지 안쪽의 블록(inner block)을 선택.
|v_aB|			"[{"에서 "]}"까지의 블록 하나(a block)를 괄호를
			포함하여 선택.
|v_iB|			"[{"에서 "]}"까지 안쪽의 블록(inner block)을 선택.

==============================================================================
식별자가 어디에 쓰였는지 찾기				*ident-search*

아마 |tags|를 써서 함수나 변수가 정의된 곳으로 이동할 수 있다는 것은 알고
계실텐데요.  하지만 때로는 함수나 변수가 사용된 곳들로 이동하고 싶을 수도 있을
겁니다.  두 가지 방법이 있습니다:
1. |:grep| 명령을 쓰면 됩니다.  대부분의 유닉스 시스템에서 쓸 수 있지만, (모든
   파일을 읽으므로) 느릴 수 있고, 하나의 디렉터리 안에서만 찾습니다.
2. ID 프로그램을 쓰면 됩니다.  이 방식은 빠르고, 여러 디렉터리에서 찾을 수도
   있습니다.  이 프로그램은 위치를 데이터베이스에 저장합니다.  따라서 추가적인
   프로그램이 필요합니다.  데이터베이스를 프로그램을 고침에 따라 업데이트도
   해주어야 합니다.

GNU id-tools 사용하기:

필요한 것:
- GNU id-tools 설치 (mkid 프로그램으로 ID 파일을 만들고, lid 프로그램으로
  찾습니다.)
- "ID"라는 이름의 식별자 데이터베이스 파일이 현재 디렉터리에 있어야 합니다.
  셸에서 "mkid 파일1 파일2 .."과 같이 하여 만들 수 있습니다.

P아래 내용을 .vimrc에 추가하세요: >
	map _u :call ID_search()<Bar>execute "/\\<" . g:word . "\\>"<CR>
	map _n :n<Bar>execute "/\\<" . g:word . "\\>"<CR>

	function! ID_search()
	  let g:word = expand("<cword>")
	  let x = system("lid --key=none ". g:word)
	  let x = substitute(x, "\n", " ", "g")
	  execute "next " . x
	endfun

사용하려면, 커서를 단어 위에 놓고, "_u"를 입력하세요.  Vim이 단어를 포함하고
있는 파일을 열어줍니다.  같은 파일의 다음 단어는 "n"으로 찾을 수 있습니다.
"_n"으로 다음 파일로 넘어가세요.

위 코드는 id-utils-3.2 (가장 가까운 gnu FTP 미러에서 이 이름으로 찾아보세요)
에서 테스트 해 보았습니다.

[이 아이디어는 Andreas Kutschera가 제안하였습니다.]

==============================================================================
xterm 안에서 스크린 전환하기		*xterm-screens* *xterm-save-screen*

(comp.editors 뉴스그룹의 질문에 Juergen Weigert가 답변한 내용)

:> 또 다른 질문은 Vim을 종료한 후 그대로 화면에 그대로 남아있는 상황에 대한 
:> 것입니다.  예를 들어 보던 (편집하던) 파일의 내용이 보여지던 그대로
:> 말이에요.  Vim을 실행하기 전에 내렸던 예를 들어 "ls" 명령의 결과는
:> 사라지고, 더 이상 위로 스크롤 해도 나타나지 않습니다.  Vim 혹은 다른 유사
:> vi 편집기에서, 예전 내용을 되살릴 수 있는 방법이 있었던 것 같은데요.
:> 어떻게 하는지 모르겠습니다.  도움 주시면 감사하겠습니다.
:
:다른 분이 답을 할 수 있을 것 같은데요.  일단 vim과 vi가 동일한 xterm 설정에서
:똑같이 동작한다고 가정해보겠습니다.

똑같이 동작하지는 않을 수도 있습니다.  이건 termcap 대 terminfo 문제일 수도
있거든요.  특정 형식의 터미널이 갖는 특성들을 저장하는 데이터베이스가 두 가지
있다는 점을 알아야 합니다.  termcap과 terminfo지요.  이 때문에 그 내용이 서로
다를 때, 하필이면 문제가 되는 프로그램들이 하나는 terminfo를 쓰고 다른 하나는
termcap을 쓰면 차이가 생기게 되지요 (|+terminfo|도 참고하세요).

위 문제를 보면, ^[[?47h 와 ^[[?47l 입력에 대해 알아야합니다.  이 입력은
xterm에서 주 스크린과 대기 스크린을 전환하는 역할을 합니다.  다음과 같이 하면,
일단 간단하게 문제를 해결할 수 있습니다 >
	echo -n "^[[?47h"; vim ... ; echo -n "^[[?47l"
(여기서 ^[는 ESC문자를 의미합니다.  아래에서는 \E로 표기하고 있는 것을 보게 될
겁니다.)

Vim은 구동될 때 termcap 변수 ti (terminfo에서는 smcup)를 터미널에 보냅니다.
종료할 때는 te (terminfo에서는 rmcup)를 보내지요.  바로 여기가 위에서 언급한
제어 입력을 넣어야하는 곳이지요.

xterm termcap 값 (/etc/termcap 에서 찾을 수 있습니다)을 xterm terminfo 값
("infocmp -C xterm" 명령으로 볼 수 있습니다)과 비교해보세요.  둘다 다음과
비슷한 내용이 있어야합니다: >
	:te=\E[2J\E[?47l\E8:ti=\E7\E[?47h:

추신: 만약 차이가 있다면, 누군가(아마도 시스템 관리자?) 전체 termcap과
      terminfo 데이터베이스가 정상적인지 체크해보아야 할 겁니다.

NOTE 1: 만약 feature.h에 정의된 FEAT_XTERM_SAVE를 켜고 Vim을 다시 컴파일하면,
위에 언급한 "te"와 "ti" 항목이 내장 xterm에 포함될 겁니다.

NOTE 2: 스크린 전환을 끄고 temrcap을 바꾸고 싶지 않다면, 다음 내용을 .vimrc에
추가하세요: >
	:set t_ti= t_te=

==============================================================================
입력 모드에서 스크롤하기				*scroll-insert*

입력 모드에서 화면 밖의 내용을 보고 싶다면, CTRL-X CTRL-E 와 CTRL-X CTRL-Y 로
화면을 스크롤 할 수 있습니다.
						|i_CTRL-X_CTRL-E|

다음 매핑을 쓰면 좀 더 쉽게 할 수 있습니다: >
	:inoremap <C-E> <C-X><C-E>
	:inoremap <C-Y> <C-X><C-Y>
(위 내용을 문자 그대로 입력하세요.  'cpoptions'에서 '<' 플래그가 빠져
있어야합니다).
단, 바로 윗줄이나 아랫줄의 내용을 그대로 입력하는 기능을 쓸 수 없게 됩니다.
|i_CTRL-E|

'scrolloff' 설정을 큰 값으로 해두어도 됩니다.  언제나 커서 주위의 내용을 좀 더
볼 수 있으니까요.  만약 'scrolloff' 값이 화면 높이의 절반보다 크다면, 커서는
언제나 화면의 중간에 위치하고, 커서가 움직일 때마다 화면이 스크롤 될 겁니다.

==============================================================================
부드러운 스크롤						*scroll-smooth*

스크롤이 좀 더 부드럽게 되게 하려면, 다음 매핑을 쓰면 됩니다: >
	:map <C-U> <C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y><C-Y>
	:map <C-D> <C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E><C-E>

(위 내용을 문자 그대로 입력하세요.  'cpoptions'에서 '<' 플래그가 빠져
있어야합니다).

==============================================================================
자주 하는 철자 오류 바로잡기				*type-mistakes*

만약 자꾸만 잘못 입력하는 단어가 있다면, 이를 바로잡는 약어를 등록해보세요.
다음과 같이 하면 됩니다: >
	:ab teh the
	:ab fro for

==============================================================================
단어나 줄 수 등을 세기					*count-items*

현재 버퍼에서 특정한 패턴이 몇 번이나 나오는지 세고 싶다면, 바꾸기(substitute)
명령 뒤에 'n' 플래그를 붙여서 실제로 바꾸기가 일어나지 않도록 해보세요.
바꾸기 결과 수가 실제 출현 횟수입니다.  예: >

	:%s/./&/gn		문자
	:%s/\i\+/&/gn		단어
	:%s/^//n		줄
	:%s/the/&/gn		"the" 전체 횟수
	:%s/\<the\>/&/gn	"the"라는 단어 전체 횟수

'hlsearch'를 꺼놓거나, ":nohlsearch" 명령을 쓰면 좋을 겁니다.
찾는 패턴이 없을 때 에러가 발생하지 않도록 하려면 'e' 플래그를 추가하면
됩니다.

시각 모드에서  |v_g_CTRL-G|를 쓰는 것도 방법입니다.

여러 파일에서 패턴을 찾으려면 |:vimgrep|을 써보세요.

							*count-bytes*
바이트 단위로 세고 싶다면, 다음과 같이 하면 됩니다:

	시각 모드에서 문자들을 선택합니다 (블럭으로 해도 됩니다)
	"y"로 문자들을 복사합니다
	strlen() 함수를 사용합니다: >
		:echo strlen(@")
줄바꿈도 한 바이트를 차지한다는 데 주의하세요.

==============================================================================
커서 위치를 되돌리기					*restore-position*

파일의 다른 곳의 내용을 고친 후 다시 현재 위치로 돌아오는 매핑을 만들고 싶다고
합시다.  화면이 전혀 스크롤되지 않은 상태에서요.  예를 들어 파일을 고친 날을
표시하고 싶다면: >
   :map <F2> msHmtgg/Last [cC]hange:\s*/e+1<CR>"_D"=strftime("%Y %b %d")<CR>p'tzt`s

위치를 저장하는 부분을 해석해보면:
	ms	현재 커서의 위치를 's' 마크에 저장
	H	창의 맨 첫 줄로 이동
	mt	첫 줄의 위치를 't' 마크에 저장

위치를 복구하는 부분을 해석해보면:
	't	원래 화면의 맨 위였던 곳으로 이동
	zt	현재 줄이 창의 맨 위가 되도록 스크롤
	`s	커서의 최초 위치로 이동

좀더 고급 기능을 사용하려면 |winsaveview()|와 |winrestview()|를 살펴보세요.

==============================================================================
파일 이름 바꾸기					*rename-files*

예를 들어 다음과 같은 파일들이 있는 디렉터리가 있다고 합시다 (디렉터리는 제
마음대로 골랐습니다 ㅋ):

buffer.c
charset.c
digraph.c
...

이제 *.c 파일들을 *.bla로 바꾸고 싶다고 해보지요. 다음과 같이 하면 됩니다: >

	$ vim
	:r !ls *.c
	:%s/\(.*\).c/mv & \1.bla
	:w !sh
	:q!

==============================================================================
여러 파일에서 이름 바꾸기				*change-name*

여러 파일에서 이름을 바꾸는 스크립트를 만들어봅시다:

	"subs.vim"이란 파일을 만들고, 바꾸기와 :update (바뀐 내용이 있을 때만
	저장) 명령을 입력합시다: >
		:%s/Jones/Smith/g
		:%s/Allen/Peter/g
		:update
<
	Vim으로 바꿀 파일들을 모두 열고, 모든 인자에 대해 스크립트를
	실행시킵시다: >

		vim *.let
		argdo source subs.vim

|:argdo|도 참고하세요.

==============================================================================
외부 명령 속도 높이기					*speed-up*

어떤 환경에서는 외부 명령어를 실행하는 것이 아주 느릴 수도 있겠지요.
유닉스에서 와일드카드 확장이 느릴 수도 있습니다.  속도를 높일 수 있는 방법을
몇 가지 말씀드리겠습니다.

.cshrc(혹은 사용하는 셸에 따라 다른 파일)이 매우 길다면, 이 파일을 대화형
사용을 위한 부분과 (보통 보조 셸(secondary-shell)이라고 부르는) 대화형 사용이
아닌 부분으로 나누세요.  Vim에서 ":!ls" 같은 명령을 내릴 때는 대화형 사용에
관한 내용은 필요가 없으니까요(예를 들어 프롬프트 설정).  대화형 사용에만
필요한 부분을 다음 내용 아래 쪽에 넣으세요: >

	if ($?prompt == 0) then
		exit 0
	endif

다른 방법은 'shell' 설정에 "-f" 플래그를 추가하는 것입니다.  예를 들어: >

	:set shell=csh\ -f

(백슬래시는 설정값에 공백을 포함시키기 위해 필요합니다).
이렇게 하면 .cshrc를 아예 무시할 겁니다.  다만 원래 동작하던 것 중 안되는 것이
생길 수도 있으니 주의하세요.

==============================================================================
유용한 매핑들						*useful-mappings*

사람들이 좋아하는 매핑 몇 가지를 소개합니다.

							*map-backtick*  >
	:map ' `
작은 따옴표가 백틱처럼 동작하도록 합니다.  커서를 마크의 위치가 아니라 줄의
공백이 아닌 첫 문자로 이동시킵니다.

							*emacs-keys*
명령줄에서 이맥스(Emacs) 처럼 편집하려면: >
	" 줄의 처음으로
	:cnoremap <C-A>		<Home>
	" 한 글자 왼쪽으로
	:cnoremap <C-B>		<Left>
	" 커서 밑의 글자를 하나 지움
	:cnoremap <C-D>		<Del>
	" 줄의 끝으로
	:cnoremap <C-E>		<End>
	" 한 글자 오른쪽으로
	:cnoremap <C-F>		<Right>
	" 더 최근에 사용한 명령으로
	:cnoremap <C-N>		<Down>
	" 더 예전에 사용한 명령으로
	:cnoremap <C-P>		<Up>
	" 한 단어 왼쪽으로
	:cnoremap <Esc><C-B>	<S-Left>
	" 한 단어 오른쪽으로
	:cnoremap <Esc><C-F>	<S-Right>

NOTE: 위와 같이 쓰려면 'cpoptions' 설정에 '<' 플래그가 없어야합니다. |<>|

							*format-bullet-list*
아래는 불릿 표시가 있는 목록의 형식을 맞추는 매핑입니다.  목록의 각 줄마다 위
아래에 빈 줄이 하나씩 있어야합니다.  아래에는 설명을 붙이려다보니 복잡한
표현식을 썼습니다.  >

	:let m =     ":map _f  :set ai<CR>"   " 자동들여쓰기('autoindent')를
	:let m = m			      " 켜야합니다.
	:let m = m . "{O<Esc>"		      " 항목의 위에 빈 줄을 넣습니다.
	:let m = m . "}{)^W"		      " 불릿 뒤로 이동합니다.
	:let m = m . "i     <CR>     <Esc>"   " 들여쓰기 용 공백을 넣습니다.
	:let m = m . "gq}"		      " 불릿 뒤 내용 형식을 맞춥니다.
	:let m = m . "{dd"		      " 빈 줄을 지웁니다.
	:let m = m . "5lDJ"		      " 내용을 불릿 뒤로 옮깁니다.
	:execute m			      |" 매핑을 정의합니다.

(<> 표기법 |<>|.  위 내용을 글자 그대로 입력해야한다는 데 주의하세요.  ^W는
"^"와 "W"입니다.  CTRL-W가 아니라요.  위 내용을 그대로 복사해다 Vim에 붙여넣을
수 있습니다.  'cpoptions'에 '<'가 없다면요.)

마지막 줄의 주석이 |"로 시작하는 것을 발견하셨나요?  ":execute" 명령은 "를
주석으로 인식하지 못하기 때문에 위와 같이 써야합니다.

또한, 'textwidth'를 0이 아닌 값으로 설정해야합니다.  예를 들어 >
	:set tw=70

비슷한 일을 하지만, 첫 줄의 들여쓰기를 가져다 사용하는 매핑도 다음과 같이 만들
수 있습니다 (Note: 이 매핑은 공백이 아주 많이 들어있는 한 줄짜리입니다): >
	:map _f :set ai<CR>}{a                                                          <Esc>WWmmkD`mi<CR><Esc>kkddpJgq}'mJO<Esc>j
<
							*collapse*
아래 두 매핑은 연속된 빈 줄(;b)이나 공백으로만 이루어진 줄(;n)들을 하나의 줄로
바꿔줍니다 >
    :map ;b   GoZ<Esc>:g/^$/.,/./-j<CR>Gdd
    :map ;n   GoZ<Esc>:g/^[ <Tab>]*$/.,/[^ <Tab>]/-j<CR>Gdd

==============================================================================
도움말 파일 압축하기					*gzip-helpfile*

만약 디스크 공간이 정말 부족하다면, 도움말을 압축하더라도 Vim에서 볼 수
있습니다.  도움말이 조금 늦게 열리고, "gzip" 프로그램도 있어야하겠지만요.

(1) 모든 도움말 파일을 압축합니다: "gzip doc/*.txt".

(2) "doc/tags"를 열어서, ".txt"를 모두 ".txt.gz"로 바꿉니다: >
	:%s=\(\t.*\.txt\)\t=\1.gz\t=

(3) vimrc에 아래 내용을 추가합니다: >
	set helpfile={dirname}/help.txt.gz

여기서 {dirname}은 도움말 파일이 존재하는 디렉터리입니다.  |gzip| 플러그인이
알아서 파일의 압축을 풀어줍니다.
$VIMRUNTIME은 꼭 다른 Vim 관련 파일들이 있는 곳을 가리켜야합니다.  압축한
"doc" 디렉터리가 다른 곳에 있다면요.  |$VIMRUNTIME|을 참고하세요.

==============================================================================
창에서 쉘 명령 실행하기					*shell-window*

Vim의 창 내부에서 셸 명령을 실행할 수 없냐는 질문이 많았습니다.  답은
"불가능"입니다.  그런 기능을 넣으려면 많은 코드를 추가해야한다는 것도 좋은
이유겠지요.  하지만 무엇보다 Vim은 편집기이고, 편집이 아닌 다른 일을 하라고
만드는 것이 아닙니다.  하지만 이와 비슷한 효과를 내기 위해, "splitvt"
프로그램으로 터미널이나 창 화면을 반으로 나누어 쓸 수도 있을 겁니다.
프로그램은 ftp 서버에서 받으세요.  여기에 대해서는 Sam Lantinga
<slouken@cs.ucdavis.edu>가 더 잘 알겁니다.  다른 대안은 BSD 유닉스 시스템에
있는 "window" 명령을 사용하는 것인데요.  창 여러 개를 중첩시켜서 쓸 수
있습니다.  아니면 여러 창을 오가며 쓸 수 있게 해주는 "screen" 프로그램도
있습니다.  www.uni-erlangen.de (역주: 2015년 1월 현재 다른 페이지로
연결됩니다.)에서 받으세요.

==============================================================================
16진수 편집					*hex-editing* *using-xxd*

사용설명서의 |23.4|를 참고하세요.

exe나 bin 등의 이진 파일 편집에 사용하는 어떤 확장 기능이 있다면, 다음과 같은
식의 자동명령을 만들어서 .vimrc에 추가해놓으면 편할겁니다.  "*.bin" 부분에
원하는 확장자들을 ,로 구분해서 넣으세요: >

	" vim -b : 이진 파일을 xxd 형식으로 편집
	augroup Binary
	  au!
	  au BufReadPre  *.bin let &bin=1
	  au BufReadPost *.bin if &bin | %!xxd
	  au BufReadPost *.bin set ft=xxd | endif
	  au BufWritePre *.bin if &bin | %!xxd -r
	  au BufWritePre *.bin endif
	  au BufWritePost *.bin if &bin | %!xxd
	  au BufWritePost *.bin set nomod | endif
	augroup END

==============================================================================
자동명령에서 <>표기법 사용하기				*autocmd-<>*

<> 표기법은 :autocmd 자동명령의 인자에서 인식되지 않습니다.  특수문자를
입력해야하는 불편을 피하려면, 자동 폭파 매핑을 <> 표기법을 사용하여 입력하고,
이 매핑을 자동명령에서 불러주면 됩니다.  예: >

						*map-self-destroy*  >
 " 아래는 파일명을 자동으로 메뉴 목록에 넣어주는 자동명령입니다.
 " 자동 폭파 매핑을 쓰고 있습니다!
 " 1. 버퍼의 한 줄을 써서 파일명의 마침표를 \. 로 바꿉니다.
 " 2. 바꾼 이름을 " 레지스터에 저장합니다
 " 3. 이 이름을 Buffers 메뉴에 추가합니다
 " 경고: 아래 내용은 부작용이 있습니다.  현재 레지스터의 내용이 날아가고,
 " i"에 지정된 매핑도 사라집니다.
 "
 autocmd BufNewFile,BufReadPre * nmap i :nunmap i<CR>O<C-R>%<Esc>:.g/\./s/\./\\./g<CR>0"9y$u:menu Buffers.<C-R>9 :buffer <C-R>%<C-V><CR><CR>
 autocmd BufNewFile,BufReadPre * normal i

다른 더 좋은 방법은, ":execute" 명령을 쓰는 겁니다.  <> 표기법을 백슬래시만
붙이면 쓸 수 있습니다.  이미 존재하는 백슬래시는 백슬래시 두 개로 표시하고,
따옴표 앞에 백슬래시를 추가하는 것도 잊지 마세요.
>
  autocmd BufNewFile,BufReadPre * exe "normal O\<C-R>%\<Esc>:.g/\\./s/\\./\\\\./g\<CR>0\"9y$u:menu Buffers.\<C-R>9 :buffer \<C-R>%\<C-V>\<CR>\<CR>"

실제로는 버퍼 메뉴를 관리할 때 사용자 함수를 사용해야합니다(|:function|을
참고하세요).  하지만, 그 때는 <> 표기법을 사용하지 않으니, 위 예제가 꼭 필요한
것은 아니네요.

==============================================================================
짝이 되는 괄호 강조하기						*match-parens*

아래 예는 몇 가지 고급 기술을 사용합니다:
- |CursorMoved| 자동명령 이벤트를 사용
- |searchpairpos()| 함수로 짝이 되는 괄호를 찾음
- |synID()| 함수로 커서가 문자열에 있는지, 주석에 있는지 확인
- |:match| 로 원하는 내용을 강조
- 파일의 특정한 위치를 찾기 위해 |pattern| 을 사용

아래 내용은 스크립트 지역 변수를 사용하므로 Vim 스크립트 파일에 넣어야합니다.
시작 커서 위치가 문자열이나 주석 안에 있지 않다면, 문자열이나 주석의 괄호는
무시합니다.  문법 강조가 켜져있어야 합니다.

좀 더 개선한 버전을 |matchparen| 플러그인에서 사용하고 있습니다.
>
	let s:paren_hl_on = 0
	function s:Highlight_Matching_Paren()
	  if s:paren_hl_on
	    match none
	    let s:paren_hl_on = 0
	  endif

	  let c_lnum = line('.')
	  let c_col = col('.')

	  let c = getline(c_lnum)[c_col - 1]
	  let plist = split(&matchpairs, ':\|,')
	  let i = index(plist, c)
	  if i < 0
	    return
	  endif
	  if i % 2 == 0
	    let s_flags = 'nW'
	    let c2 = plist[i + 1]
	  else
	    let s_flags = 'nbW'
	    let c2 = c
	    let c = plist[i - 1]
	  endif
	  if c == '['
	    let c = '\['
	    let c2 = '\]'
	  endif
	  let s_skip ='synIDattr(synID(line("."), col("."), 0), "name") ' .
		\ '=~?	"string\\|comment"'
	  execute 'if' s_skip '| let s_skip = 0 | endif'

	  let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip)

	  if m_lnum > 0 && m_lnum >= line('w0') && m_lnum <= line('w$')
	    exe 'match Search /\(\%' . c_lnum . 'l\%' . c_col .
		  \ 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
	    let s:paren_hl_on = 1
	  endif
	endfunction

	autocmd CursorMoved,CursorMovedI * call s:Highlight_Matching_Paren()
	autocmd InsertEnter * match none
<

 vim:tw=78:ts=8:ft=help:norl:
